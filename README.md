# 词云生成器 项目说明

本项目是一个“产品化词云”小应用：后端负责**解析输入**与**计算语义关联边**，前端负责**两种布局算法的渲染**（螺旋线词云、力导向语义图词云），并提供缩放/拖拽/高亮/Tooltip 等交互。


---

## 目录

- [整体架构](#整体架构)
- [数据流与核心数据结构](#数据流与核心数据结构)
- [前端算法](#前端算法)
  - [A. 螺旋线词云（Spiral / d3-cloud 思路）](#a-螺旋线词云spiral--d3-cloud-思路)
  - [B. 力导向布局（Force-directed）](#b-力导向布局force-directed)
  - [C. 矩形碰撞：AABB + 四叉树（rectCollide）](#c-矩形碰撞aabb--四叉树rectcollide)
  - [D. 边界约束（bounds force）](#d-边界约束bounds-force)
  - [E. Zoom/Drag 的坐标体系（世界坐标）](#e-zoomdrag-的坐标体系世界坐标)
  - [F. 高亮与 1-hop/2-hop 邻域](#f-高亮与-1-hop2-hop-邻域)
  - [G. Tooltip（SVG 内部 tooltip）](#g-tooltipsvg-内部-tooltip)
- [后端算法](#后端算法)
  - [H. 输入解析与清洗（parseText / parseFile）](#h-输入解析与清洗parsetext--parsefile)
  - [I. 语义边生成（getSemanticLinks）](#i-语义边生成getsemanticlinks)
- [工程要点与可扩展方向](#工程要点与可扩展方向)
- [许可](#许可)

---

## 整体架构

- **后端（FastAPI）**
  - 解析用户输入（文本/CSV/XLSX）得到词表：`[{text, weight}]`
  - 基于词表计算语义相似边：`[{source, target, sim}]`
- **前端（D3 + SVG）**
  - 螺旋线布局：偏“传统词云”
  - 力导向布局：偏“语义关系图”（支持拖拽、缩放、高亮与 tooltip）

---

## 数据流与核心数据结构

### 1) Words（词）

前端/后端统一使用“词+权重”的抽象：

- `text`: string，词文本
- `weight`: number，权重（可来自词频或业务分数）

前端会把 `weight` 映射到字号 `size`：

- 常用缩放为开方尺度（sqrt scale），避免大词过大挤压小词

### 2) Links（边）

后端输出语义边：

- `source`: number（词索引）或可解析为 id
- `target`: number（词索引）
- `sim`: number in \[0,1\]，语义相似度或相关性强度

前端基于 `sim` 设定：

- link 的长度（`distance`）：相似度越高，距离越短（更聚）
- link 的强度（`strength`）：相似度越高，越“拉得住”
- 高亮时的线宽/不透明度：按 `sim` 强化信息密度

---

## 前端算法

### A. 螺旋线词云（Spiral / d3-cloud 思路）

**目标**：给每个词找到一个不重叠的位置，视觉上形成“词云”聚团效果。

**典型流程**（与 d3-cloud 思路一致）：

1. 将词按字号从大到小排序（大词先放，决定主结构）。
2. 对每个词，从画布中心附近开始搜索候选位置。
3. 候选位置按螺旋线参数化生成（常见为阿基米德螺旋）：
   
   $
   x(t) = x_0 + a t \cos(t), \quad y(t) = y_0 + a t \sin(t)
   $
   
   其中 $t$ 递增，点逐渐向外扩展；$a$ 控制螺旋疏密。
4. 每尝试一个点，就做一次“是否与已放置词重叠”的检测。
5. 找到第一个可行位置就固定该词，进入下一个词。

**重叠检测**：
- 若使用像素级 mask：精确但成本高
- 本项目更偏工程稳定：使用 bbox / 近似矩形碰撞（速度快，结果可接受）

**优点**：布局稳定、结果“像传统词云”。  
**缺点**：不表达词与词之间的关系（除非额外叠加连线，但空间语义弱）。

---

### B. 力导向布局（Force-directed）

**目标**：将每个词视为图上的节点，语义边视为弹簧，使“相近的词”更靠近，同时通过碰撞力避免重叠。

本项目使用 D3 force simulation 的常见组合力：

- **中心力**：整体聚在画布中央
- **多体力（charge）**：节点之间有一定排斥，避免全挤成一团
- **连边弹簧力（link）**：相似词更靠近，弱相似词更远
- **矩形碰撞力（rectCollide，自定义）**：以 AABB 防止文字重叠
- **边界力（bounds，自定义）**：不让节点跑出画布

这种系统可视作在迭代求解一个能量最小化过程：弹簧趋向缩短目标距离、排斥与碰撞提供约束，最后在阻尼下收敛。

---

### C. 矩形碰撞：AABB + 四叉树（rectCollide）

**问题**：D3 自带 `forceCollide` 多用于圆形半径碰撞；文本更接近矩形，且旋转时外接矩形不同。

**解法**：用**轴对齐包围盒（AABB）**作为碰撞形状：

- 每个节点保存碰撞箱尺寸：`node.cbox = {w, h}`（推荐与 UI 虚拟框一致）
- 节点位置 $(x, y)$ 表示矩形中心
- 两矩形重叠判定：
  - x 方向重叠量：$$
    p_x = \frac{w_a + w_b}{2} - |x_a - x_b|
    $$
  - y 方向重叠量：$$
    p_y = \frac{h_a + h_b}{2} - |y_a - y_b|
    $$
  - 当 $p_x > 0$ 且 $p_y > 0$ 时发生重叠

**分离策略**：
- 沿“重叠更小”的轴分离（更稳定）：
  - 若 $p_x < p_y$，推开 x 方向；否则推开 y 方向
- 推开的量按强度与当前 $\alpha$（模拟退火参数）缩放

**稳定性关键点（工程经验）**：
- **不要直接修改 `x/y`**（瞬移会引起振荡）
- 推荐修改速度 `vx/vy`，并随 $\alpha$ 衰减；再由 `velocityDecay`（阻尼）稳定收敛

**加速**：使用 **四叉树（quadtree）**做近邻剪枝：  
只访问与节点 AABB 有可能相交的象限，降低复杂度。

---

### D. 边界约束（bounds force）

**问题**：力导向可能把节点推到画布外。

**做法**：对每个节点施加边界“回推”：

- 若 $x - w/2 < margin$，则增加向右的速度/位移
- 若 $x + w/2 > W - margin$，则增加向左的速度/位移
- y 方向同理

这是一个软约束（soft constraint），比硬裁剪更自然。

---

### E. Zoom/Drag 的坐标体系（世界坐标）

**问题**：当画布被缩放/平移后，拖拽事件给到的是屏幕坐标；节点在“世界坐标”中运动。如果不转换，会出现拖拽错位。

**解法**：
- 获取当前 zoom transform：`t = d3.zoomTransform(svgEl)`
- 获取鼠标在 svg 上的屏幕坐标：`p = d3.pointer(event, svgEl)`
- 转换为世界坐标：`world = t.invert(p)`

这样拖拽时设置 `d.fx = world[0]`, `d.fy = world[1]` 才能与仿真坐标一致。

---

### F. 高亮与 1-hop/2-hop 邻域

**需求**：用户 hover/点击某个词时，希望“看懂关系”：

- 高亮当前词
- 高亮与其相连的边与邻居词（1-hop）
- 可选扩展到 2-hop（邻居的邻居），但透明度应更弱

**算法**：

1. 构建邻接表：
   - `neighbors[id] = Set(邻居id)`
2. 计算邻域层：
   - $L_0$：自身
   - $L_1$：一阶邻居
   - $L_2$：二阶邻居（遍历 $L_1$ 的邻居，并去重/排除 $L_0$ 与 $L_1$）
3. 样式映射（示例）：
   - $L_0$：opacity 1，描边/发光
   - $L_1$：opacity 1
   - $L_2$：opacity ~0.5
   - 其他：opacity ~0.1~0.2

**交互状态（方案三）**：
- `hoverId`：鼠标悬浮预览
- `selectedId`：点击锁定（再次点击取消、点击空白清除）
- `draggingId`：拖拽中优先高亮
- 生效优先级：`draggingId > selectedId > hoverId`

---

### G. Tooltip（SVG 内部 tooltip）

**目标**：让高亮“可解释”，在当前词附近显示：
- 词文本、weight
- degree（连接数）
- top-N 邻居与相似度（sim）

**实现要点**：
- Tooltip 作为 `root` 内的 `<g>`，这样会自然跟随 zoom/pan
- 内容用 `<text><tspan>...</tspan></text>` 多行排版
- 背景 `<rect>` 的尺寸通过 `text.getBBox()` 动态计算
- Tooltip 位置使用“节点中心 + 碰撞箱偏移”，避免遮挡文字

---

## 后端算法

> 由于不同部署场景可能会替换模型/策略，以下描述的是项目中“后端职责”与常用实现方式；具体实现以 `api.py` / 路由文件为准。

### H. 输入解析与清洗（parseText / parseFile）

**目标**：将用户输入（手写文本、CSV、XLSX）统一转成结构化词表 `[{text, weight}]`。

常见步骤：

1. **解析**：
   - 手写：按行切分；支持 `word` 或 `word,weight`
   - CSV：按列识别（可能是 `word/weight` 两列或仅一列）
   - XLSX：读取首个 sheet 或用户指定 sheet，取前两列
2. **清洗**：
   - 去除空白行/空词
   - weight 缺失则给默认值（如 1）
   - 合并重复词：同词累加 weight 或取最大（按需求）
3. **限制**（工程控制）：
   - 最大词数上限，防止前端渲染过载
   - weight 过大/过小可做裁剪或归一化

---

### I. 语义边生成（getSemanticLinks）

**目标**：给词表生成“语义相似”边，用于力导向布局中的 link force。

典型算法管线：

1. **向量表示（Embedding）**
   - 将每个词/短语映射为向量 $e_i \in \mathbb{R}^d$
   - 可选来源：
     - 预训练句向量模型（Sentence-BERT 等）
     - 向量服务（在线 embedding API）
     - 规则/统计特征（demo 环境可先用简化策略）

2. **相似度计算**
   - 余弦相似度最常用：
     $$
     \text{sim}(i,j) = \frac{e_i \cdot e_j}{\|e_i\|\|e_j\|}
     $$
   - 将 $\text{sim}$ 归一到 $[0,1]$（取决于模型输出范围与实现）

3. **建边策略（TopK + Threshold）**
   - 对每个节点 $i$：
     - 找到相似度最高的前 $K$ 个节点
     - 过滤掉 $\text{sim} < \tau$ 的候选
   - 只保留 $i<j$ 的无向边去重

4. **复杂度优化**
   - 直接两两相似是 $O(n^2)$，当词很多时会慢
   - 可选优化：
     - 使用近似最近邻（ANN，如 HNSW / FAISS）获取 TopK
     - 或在后端缓存 embedding、增量更新

**输出**：
- `source, target` 使用词索引，前端可直接作为 d3.forceLink 的 id
- `sim` 用于：
  - link distance/strength
  - 高亮时的线宽/透明度映射
  - tooltip 展示解释

---
